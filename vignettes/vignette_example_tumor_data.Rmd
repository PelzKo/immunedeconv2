---
title: "Vignette for book chapter"
author: "Lorenzo Merotto"
date: "2023-11-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Library loading 

```{r}
library(Seurat)
library(tidyverse)
library(omnideconv)
library(readxl)
```

```{r, echo=FALSE, results='hide'}

setwd("C:/Users/c1041161/book_chapter/")

signature.matrix.dwls <- readRDS('./signature.dwls.rds')
signature.matrix.dwls.minor <- readRDS('./signature.dwls.minor.rds')
deconvolution.results.dwls <- readRDS('./deconvolution.dwls.rds')
deconvolution.results.dwls.minor <- readRDS('./deconovlution.results.dwls.minor.rds')
deconvolution.results.music <- readRDS('./deconvolution.music.rds')
deconvolution.results.bayesprism <- readRDS('./deconvolution_results_bayesprism.rds')
```


# Single cell data processing 

First of all, we will need to process the single cell dataset in order to remove low quality cells. We will create a Seurat object with the cell counts and their metadata of interest curated by the authors, which include cell type annotation on three levels of resolution

```{r}

single.cell.data <- Seurat::ReadMtx(
  mtx = './Wu_etal_2021_BRCA_scRNASeq/count_matrix_sparse.mtx',
  cells = './Wu_etal_2021_BRCA_scRNASeq/count_matrix_barcodes.tsv',
  features = './Wu_etal_2021_BRCA_scRNASeq/count_matrix_genes.tsv',
  feature.column = 1
)
single.cell.metadata <- read.table('./Wu_etal_2021_BRCA_scRNASeq/metadata.csv', 
                                   sep = ',',
                                   header = TRUE, 
                                   row.names = 1)

single.cell.data = CreateSeuratObject(single.cell.data, 
                                      project='Wu_dataset', 
                                      assay='RNA', 
                                      min.cells = 0, 
                                      min.features = 1, meta.data = single.cell.metadata)
```

We can have an overview of the number of cells per cell type in the dataset:

```{r}
table(single.cell.data$celltype_major, dnn = list("celltype_major")) %>%
      as.data.frame(., responseName = "number_cells")
```

In order to remove low quality cells, we will follow the [best practices for single cell normalization](https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html). We will perform the quality control on each cell considering as metrics the number of counts, the number of features (genes) and the fraction of mitochondrial genes. The metric considered is the MAD, (Mean Absolute Deviation), computed as $MAD = median(|X_i - median(X)|)$ with $X_i$ being the respective metric of an observation (cell). 
We will consider as outliers cells that have $X_i < n*|MAD|$, with $n=5$ for number of counts and number of features, and n=3 for the fraction of mitochondrial genes.

```{r}
is_outlier <- function(SeuratObject, metric, nmads){
  eval(parse(text = paste0("M <- SeuratObject$",metric)))
  outlier <- (M < median(M) - nmads * mad(M)) | (M > median(M) + nmads * mad(M))
  return(outlier)
}

check_outliers_nFeature <- is_outlier(single.cell.data, 'nFeature_RNA', 5)
check_outliers_nCount <- is_outlier(single.cell.data, 'nCount_RNA', 5)
check_outliers_mito <- is_outlier(single.cell.data, 'percent.mito', 3)

non_outliers_nFeature <- names(check_outliers_nFeature[!check_outliers_nFeature])
non_outliers_nCount <- names(check_outliers_nCount[!check_outliers_nCount])
non_outliers_mito <- names(check_outliers_mito[!check_outliers_mito])
```

We will retain only those that satisfy all three of the conditions described above.

```{r}
non_outliers <- intersect(non_outliers_nFeature, non_outliers_nCount) %>% 
  intersect(non_outliers_mito)

single.cell.data <- subset(single.cell.data, cells = non_outliers)

as.data.frame(table(single.cell.data$celltype_major, dnn = list("celltype_major")), responseName = "number_cells")

```


# Bulk data preprocessing

We will now read in the bulk sequencing data file, which consists of 24 samples.

```{r}
bulk.data <- read.table('./GSE176078_Wu_etal_2021_bulkRNAseq_raw_counts.txt', skip=1)

header <- read.table('./GSE176078_Wu_etal_2021_bulkRNAseq_raw_counts.txt', 
                     header = FALSE, nrows = 1, skipNul = TRUE, sep='\t')

colnames(bulk.data) <- c('Genes', gsub('A|N', '', header[2:25]))

bulk.data <- bulk.data[bulk.data$Genes != '', ]
bulk.data <- column_to_rownames(bulk.data, 'Genes')
bulk.data <- as.matrix(bulk.data)
```


# Subsampling of single cell data 

The various methods included in omnideconv rely on the single cell dataset that will be used to train them for the deconvolution of those specific cell types. This training involves the optimization of internal features of the methods and can happen in different ways. Some methods use the single cell data to build a 'signature matrix', i.e. a reduced transcriptional fingerprints of the cell types provided, while others use this data in a statistical or deep learning model. 
Since single cell datasets can often encompass thousands of cells, we will need to subsample it in order to be able to run the analysis on our machines. In this case we will retain a maximum of 200 cells per cell type, but this step can be costumed, or eventually skipped, depending on the computational resources available.

```{r}
max_cells_per_celltype = 200

sampled.metadata <- single.cell.data@meta.data %>%
      rownames_to_column(., 'barcode') %>%
      group_by(., celltype_major) %>% 
      nest() %>%            
      mutate(n =  map_dbl(data, nrow)) %>%
      mutate(n = min(n, max_cells_per_celltype)) %>%
      ungroup() %>% 
      mutate(samp = map2(data, n, sample_n)) %>% 
      select(-data) %>%
      unnest(samp)

single.cell.data.sampled <- subset(single.cell.data, cells = sampled.metadata$barcode)


as.data.frame(table(single.cell.data.sampled$celltype_major, dnn = list("celltype_major")), responseName = "number_cells")

```


# Deconvolution of the bulk data 

Each methods has different requirements, but in general to compute the deconvolution results we will need the single cell counts matrix, the cell type annotations and the information on the individual/experiment fom which the cells were retrieved (batch ID).

```{r}
counts.matrix <- as.matrix(single.cell.data.sampled@assays$RNA@counts)
cell.type.annotations <- single.cell.data.sampled$celltype_major
batch.ids <- single.cell.data.sampled$orig.ident
```

## Deconvolution with DWLS

Now we're going to deconvolute the bulk dataset with different methods. 
The first one we are going to use is called [DWLS](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6611906/) and performs the deconvolution in a two-steps process. First, the single cell data is used to build a signature matrix using the `omnideconv` function `build_model`:

```{r, eval=FALSE}
# We need to insert the normalization as well
signature.matrix.dwls <- omnideconv::build_model(single_cell_object = counts.matrix,
                        cell_type_annotations = cell.type.annotations,
                        method = 'dwls', 
                        dwls_method = 'mast_optimized')

```

This signature is optimized so that the genes selected are the ones that help to discriminate across cell types, and it can be manually inspected. 

```{r}
head(signature.matrix.dwls)
```

The signature is now used for the deconvolution of the bulk RNAseq, which is performed with the `omnideconv` function `deconvolute`.

```{r, eval=FALSE}
deconvolution.results.dwls <- deconvolute(bulk_gene_expression = bulk.data,
                                          signature = signature.matrix.dwls,
                                          method='dwls',
                                          dwls_submethod = 'DampenedWLS')
```

We will now obtain, for every sample, a set of cell type fractions for each cell type that was included in the provided single cell dataset. 

```{r}
head(deconvolution.results.dwls)
```

We can also visualise the results as a barplot trough the built-in `plot_deconvolution` function

```{r}
omnideconv::plot_deconvolution(list('dwls' = deconvolution.results.dwls), "bar", "method", "Spectral")

omnideconv::plot_deconvolution(list('dwls' = deconvolution.results.dwls.minor), "bar", "method", "Spectral")
```



# BayesPrism deconvolution

The third method we will use is [BayesPrism](https://www.nature.com/articles/s43018-022-00356-3). This method is based on a Bayesian framework and models the transcriptomic expression observed in the scRNA-seq dataset. It then uses this information to dissect te bulk RNA-seq.  

```{r,eval=FALSE}
# BayesPrism deconvolution

deconvolution.results.bayesprism <- deconvolute(bulk_gene_expression = bulk.data,
                                           single_cell_object = counts.matrix,
                                           cell_type_annotations = cell.type.annotations,
                                           signature=NULL,
                                           method = 'bayesprism', 
                                           n_cores=12)
```

We can visualize the results as before: 

```{r}
omnideconv::plot_deconvolution(list('bayesprism' = deconvolution.results.bayesprism), "bar", "method", "Spectral")
```


# Deconvolution of cell types at a lower resolution 

The considered single-cell breast cancer dataset includes cell-type annotations at three levels of resolution: `celltype_major`, `celltype_minor`, and `celltype_subset`, which distinguish 9, 29, and 58 cell types respectively. 
The different cell-type annotations can be accessed with: 

```{r, eval=FALSE}
single.cell.data$celltype_major   # Major annotation
single.cell.data$celltype_minor   # Minor annotation
single.cell.data$celltype_subset           # Subset annotation
```

These additional annotations provide a cell-type classification at a finer resolution. For instance, at the `celltype_major` level, we only have the T cell population, while at the `celltype_minor` level, we can distinguish between CD4+ and CD8+ T cells. In the following, we will again perform deconvolution analysis with DWLS but, this time, using the `celltype_minor` information. We will subsample the dataset as before, this time considering the second level of resolution for the cell types, and extract the objects needed for deconvolution. 


```{r}
max_cells_per_celltype = 200


sampled.metadata <- single.cell.data@meta.data %>%
      rownames_to_column(., 'barcode') %>%
      group_by(., celltype_minor) %>% 
      nest() %>%            
      mutate(n =  map_dbl(data, nrow)) %>%
      mutate(n = min(n, max_cells_per_celltype)) %>%
      ungroup() %>% 
      mutate(samp = map2(data, n, sample_n)) %>% 
      select(-data) %>%
      unnest(samp)

single.cell.data.sampled <- subset(single.cell.data, cells = sampled.metadata$barcode)


as.data.frame(table(single.cell.data.sampled$celltype_minor, dnn = list("celltype_minor")), responseName = "number_cells")
```


```{r}
counts.matrix <- as.matrix(single.cell.data@assays$RNA@counts)
cell.type.annotations <- single.cell.data$celltype_minor
batch.ids <- single.cell.data$orig.ident
```


```{r, eval=FALSE}

signature.matrix.dwls.minor <- omnideconv::build_model(single_cell_object = counts.matrix,
                        cell_type_annotations = cell.type.annotations,
                        method = 'dwls', 
                        dwls_method = 'mast_optimized')

deconvolution.results.dwls.minor <- deconvolute(bulk_gene_expression = bulk.data,
                                          signature = signature.matrix.dwls.minor,
                                          method='dwls',
                                          dwls_submethod = 'DampenedWLS')
```



We can visualize the results as before: 

```{r}
omnideconv::plot_deconvolution(list('dwls' = deconvolution.results.dwls.minor), "bar", "method", "Spectral")
```


# Comparison of cell fractions across conditions

We can consider as well the metadata provided with the original paper, which include patient's data, cancer subtype information and treatment details. We can first harmonize the sample names, and then combine all this information with the deconvolution results in one dataframe.

```{r}
patient.metadata <- read_excel("./41588_2021_911_MOESM4_ESM.xlsx", sheet = 1, skip = 3) %>%
  select(., c(1, 4, 5, 11, 12))
colnames(patient.metadata) <- c('Sample', 'Grade', 'Cancer_type', 'IHC_subtype', 'Treatment')

patient.metadata$Sample <- gsub('-', '', patient.metadata$Sample) %>%
  paste0('CID', .)

patients.results <- rownames_to_column(as.data.frame(deconvolution.results.dwls), 'Sample') %>%
  gather(., key='celltype', value='cell_fraction', -Sample) %>%
  left_join(., patient.metadata)

```
Each condition has a different number of samples: 

```{r}
as.data.frame(table(patient.metadata$IHC_subtype, dnn = list("IHC_subtype")), responseName = "number_patients")

```

We can visualize the estimated cell fractions across samples with a boxplot, and group the results either by IHC subtype or by treatment status

```{r}
ggplot(patients.results, aes(x=celltype, y=cell_fraction, fill=IHC_subtype))+
  geom_boxplot()+
  ylab("cell fractions") +
  xlab("") +
  scale_fill_discrete(name="IHC subtype") +
  theme_bw() +
  theme(axis.text.x= element_text(angle=60, hjust = 1 )) 
```

HER2-positive samples are enriched in T cells, while the ER-positive and triple negative breast cancer (TNBC) samples show an enrichment in cancer and normal epithelial cells, respectively. 
The patient metadata includes information about eventual treatments undergone by the patients. We can see that 5 out of the 24 patients were treated with Neoadjuvant and/or Paclitaxel, while the other 19 were untreated. We can therefore visualize the distribution of cell fractions across treated and untreated patients 


```{r}
ggplot(patients.results, aes(x=celltype, y=cell_fraction, fill=Treatment))+
  geom_boxplot()+
  ylab("cell fractions") +
  xlab("") +
  scale_fill_discrete(name="Treatment") +
  theme_bw() +
  theme(axis.text.x= element_text(angle=60, hjust = 1 )) 
```

The major differences in this case are the enrichment of the CAFs and normal epithelial cells in the treated samples, as opposed to the cancer epithelial cells and B cells which have a higher median cell fraction in the untreated samples. 
  
  
  
As mentioned before, with the lower level of annotations we can identify additional cell types, such as CD4+/CD8+ subtypes, Fibroblasts and cancer cells. We can therefore visualize the estimated cell fractions in a boxplot, focusing in particular on the CD4+ and CD8+ T-cell subtypes.



```{r}
patients.results.minor <- rownames_to_column(as.data.frame(deconvolution.results.dwls.minor), 'Sample') %>%
  gather(., key='celltype', value='cell_fraction', -Sample) %>%
  left_join(., patient.metadata)
patients.results.minor %>%
  filter(celltype %in% c('T cells CD4+', 'T cells CD8+')) %>%
ggplot(., aes(x=celltype, y=cell_fraction, fill=IHC_subtype))+
  geom_boxplot()+
  ylab("cell fractions") +
  xlab("") +
  scale_fill_discrete(name="IHC subtype") +
  theme_bw() +
  theme(axis.text.x= element_text(angle=60, hjust = 1 ))
```


The estimates for the CD8+ T cells seem to be very low for all samples. On the other hand, in the HER2/ER positive samples the cell fractions estimated for the CD4+ T cells seem to be significantly higher than in the other subtypes. The estimates for the CD8+ T cells are close to zero for almost every sample, with very low fractions detected for the HER2+/ER+ ones.
  
  
Similarly, we can visualize the distribution of the estimates for the cancer associated fibroblasts (CAFs), respectively the myoblastic CAFs (myCAF) and the bone marrow derived inflammatory CAFs (MSC iCAF).


```{r}
patients.results.minor %>%
  filter(celltype %in% c('CAFs myCAF-like', 'CAFs MSC iCAF-like')) %>%
ggplot(., aes(x=celltype, y=cell_fraction, fill=IHC_subtype))+
  geom_boxplot()+
  ylab("cell fractions") +
  xlab("") +
  scale_fill_discrete(name="IHC subtype") +
  theme_bw() +
  theme(axis.text.x= element_text(angle=60, hjust = 1 ))
```

Here we can notice that, while the myoblastic CAFs have a comparable median value, the MSC CAFs have higher infiltration in the samples characterized as HER2+/ER+ subtype. 

  

Finally, we can visualize the distribution of the different cancer cells molecular subtypes that were described by the authors. 


```{r}
patients.results.minor %>%
  filter(celltype %in% c('Cancer Basal SC', 'Cancer LumA SC', 'Cancer LumB SC', 'Cancer Her2 SC')) %>%
ggplot(., aes(x=celltype, y=cell_fraction, fill=IHC_subtype))+
  geom_boxplot()+
  ylab("cell fractions") +
  xlab("") +
  scale_fill_discrete(name="IHC subtype") +
  theme_bw() +
  theme(axis.text.x= element_text(angle=60, hjust = 1 )) +
  labs(title = 'Cancer cells estimated fractions')



```

We can see that the HER2+ shows an overrepresentation of the cancer cells described as HER2-like by the authors. Similarly, the ER+ samples show higher fractions of Luminal B cancer cells. These findings on bulk RNA-seq are concordant with the subtypings that the authors described on the single cell RNA-seq (‘Results - scSubtype’). 

