#' Calculates the signature model with bisque
#'
#' @param single_cell_object A matrix with the single-cell data. Rows are genes, columns are
#'   samples. Row and column names need to be set.
#' @param cell_type_annotations A Vector of the cell type annotations. Has to be in the same order
#'   as the samples in single_cell_object.
#' @param batch_ids A vector of the ids of the samples or individuals.
#' @param old_cpm Prior to version 1.0.4 (updated in July 2020), the package
#'   converted counts to CPM after subsetting the marker genes. Github user
#'   randel pointed out that the order of these operations should be switched.
#'   Thanks randel! This option is provided for replication of older BisqueRNA
#'   but should be enabled, especially for small marker gene sets.
#'   We briefly tested this change on the cortex and adipose datasets.
#'   The original and new order of operations produce estimates that have an
#'   average correlation of 0.87 for the cortex and 0.84 for the adipose within
#'   each cell type.
#' @param verbose Whether to produce an output on the console.
#'
#' @return The signature matrix. Rows are genes, columns are cell types.
#' @export
#'
build_model_bisque <- function(single_cell_object, cell_type_annotations, batch_ids, old_cpm = TRUE,
                               verbose = FALSE) {
  sc_eset <- get_single_cell_expression_set(
    single_cell_object, batch_ids,
    rownames(single_cell_object), cell_type_annotations
  )

  if (old_cpm) {
    sc_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(sc_eset),
      phenoData = sc_eset@phenoData
    )
  }
  if (verbose) {
    base::message(
      "Converting single-cell counts to CPM and ",
      "filtering zero variance genes."
    )
  }
  sc_eset <- BisqueRNA:::CountsToCPM(sc_eset)
  if (!old_cpm) {
    sc_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(sc_eset),
      phenoData = sc_eset@phenoData
    )
  }
  sc_eset <- BisqueRNA:::FilterZeroVarianceGenes(sc_eset, verbose)

  BisqueRNA::GenerateSCReference(sc_eset, "cellType")
}



#' Calculates the decomposition using the bisque algorithm
#'
#' Generates a reference profile based on single-cell data. Learns a
#' transformation of bulk expression based  on  observed  single-cell
#' proportions  and  performs  NNLS  regression  on  these  transformed
#' values to estimate cell proportions.
#'
#' @param bulk_gene_expression A matrix of bulk data. Rows are genes, columns are samples.
#'   Row and column names need to be set.
#' @param signature The signature matrix. Rows are genes, columns are cell types.
#' @param single_cell_object A matrix with the single-cell data. Rows are genes, columns are
#'   samples. Row and column names need to be set.
#' @param cell_type_annotations A vector of the cell type annotations. Has to be in the same order
#'   as the samples in single_cell_object.
#' @param batch_ids A vector of the ids of the samples or individuals.
#' @param markers Structure, such as character vector, containing marker genes
#'   to be used in decomposition. `base::unique(base::unlist(markers))` should
#'   return a simple vector containing each gene name. If no argument or NULL
#'   provided, the method will use all available genes for decomposition.
#' @param cell_types Character string. Name of phenoData attribute in sc.eset
#'   indicating cell type label for each cell.
#' @param subject_names Character string. Name of phenoData attribute in sc.eset
#'   indicating individual label for each cell.
#' @param use_overlap Boolean. Whether to use and expect overlapping samples
#'   in decomposition.
#' @param old_cpm Prior to version 1.0.4 (updated in July 2020), the package
#'   converted counts to CPM after subsetting the marker genes. Github user
#'   randel pointed out that the order of these operations should be switched.
#'   Thanks randel! This option is provided for replication of older BisqueRNA
#'   but should be enabled, especially for small marker gene sets.
#'   We briefly tested this change on the cortex and adipose datasets.
#'   The original and new order of operations produce estimates that have an
#'   average correlation of 0.87 for the cortex and 0.84 for the adipose within
#'   each cell type.
#' @param verbose Whether to produce an output on the console.
#'
#' @return A list including:
#' \item{bulk_props}{A matrix of cell type proportion estimates with cell types as rows and
#'   individuals as columns.}
#' \item{sc_props}{A matrix of cell type proportions estimated directly from counting single-cell
#'   data.}
#' \item{rnorm}{Euclidean norm of the residuals for each individual's proportion estimates.}
#' \item{genes_used}{A vector of genes used in decomposition.}
#' \item{transformed_bulk}{The transformed bulk expression used for decomposition. These values
#'   are generated by applying a linear transformation to the CPM expression.}
#'
#' @export
#'
deconvolute_bisque <- function(bulk_gene_expression, signature, single_cell_object,
                               cell_type_annotations, batch_ids, markers = NULL,
                               cell_types = "cellType", subject_names = "batchId",
                               use_overlap = FALSE, verbose = FALSE, old_cpm = TRUE) {

  # Method is BisqueRNA::ReferenceBasedDecomposition, I only added the
  # signature matrix (so ones from other method can be used)

  if (is.null(single_cell_object) || is.null(cell_type_annotations) || is.null(batch_ids)) {
    base::stop(
      "Single cell object or cell type annotations not provided. Call as: ",
      "deconvolute(bulk_gene_expression, signature, \"bisque\", single_cell_object, ",
      "cell_type_annotations, batch_ids)"
    )
  }
  sc_eset <- get_single_cell_expression_set(
    single_cell_object, batch_ids,
    rownames(single_cell_object), cell_type_annotations
  )
  bulk_eset <- Biobase::ExpressionSet(assayData = bulk_gene_expression)


  if ((!methods::is(sc_eset, "ExpressionSet")) || (!methods::is(
    bulk_eset,
    "ExpressionSet"
  ))) {
    base::stop("Expression data should be in ExpressionSet")
  } else if (!cell_types %in% Biobase::varLabels(sc_eset)) {
    base::stop(base::sprintf(
      "Cell type label \"%s\" ",
      cell_types
    ), "not found in single-cell ExpressionSet varLabels.")
  } else if (!subject_names %in% Biobase::varLabels(sc_eset)) {
    base::stop(base::sprintf(
      "Individual label \"%s\"",
      subject_names
    ), " not found in single-cell ExpressionSet varLabels.")
  }
  n_sc_individuals <- base::length(base::levels(base::factor(sc_eset[[subject_names]])))
  if (n_sc_individuals == 1) {
    base::stop(
      "Only one individual detected in single-cell data. At least ",
      "two subjects are needed (three or more recommended)."
    )
  } else if (n_sc_individuals == 2) {
    base::warning(
      "Only two individuals detected in single-cell data. While ",
      "Bisque will run, we recommend at least three subjects for ",
      "reliable performance."
    )
  }
  n_cell_types <- base::length(base::levels(base::factor(sc_eset[[cell_types]])))
  if (n_cell_types == 1) {
    base::stop(
      "Single-cell pheno data indicates only one cell type ",
      "present. No need for decomposition."
    )
  }
  if (verbose) {
    base::message(base::sprintf(
      "Decomposing into %i cell types.",
      n_cell_types
    ))
  }
  if (use_overlap) {
    samples <- BisqueRNA:::GetOverlappingSamples(
      sc_eset, bulk_eset,
      subject_names, verbose
    )
  }
  if (base::is.null(markers)) {
    markers <- Biobase::featureNames(sc_eset)
  } else {
    markers <- base::unique(base::unlist(markers))
  }
  genes <- BisqueRNA:::GetOverlappingGenes(
    sc_eset, bulk_eset, markers,
    verbose
  )
  if (old_cpm) {
    sc_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(sc_eset)[genes, ],
      phenoData = sc_eset@phenoData
    )
    bulk_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(bulk_eset)[genes, ],
      phenoData = bulk_eset@phenoData
    )
  }
  if (verbose) {
    base::message(
      "Converting single-cell counts to CPM and ",
      "filtering zero variance genes."
    )
  }
  sc_eset <- BisqueRNA:::CountsToCPM(sc_eset)
  if (!old_cpm) {
    sc_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(sc_eset)[genes, ],
      phenoData = sc_eset@phenoData
    )
  }
  sc_eset <- BisqueRNA:::FilterZeroVarianceGenes(sc_eset, verbose)
  if (verbose) {
    base::message(
      "Converting bulk counts to CPM and filtering ",
      "unexpressed genes."
    )
  }
  bulk_eset <- BisqueRNA:::CountsToCPM(bulk_eset)
  if (!old_cpm) {
    bulk_eset <- Biobase::ExpressionSet(
      assayData = Biobase::exprs(bulk_eset)[genes, ],
      phenoData = bulk_eset@phenoData
    )
  }
  bulk_eset <- BisqueRNA:::FilterUnexpressedGenes(bulk_eset, verbose)
  genes <- base::intersect(
    Biobase::featureNames(sc_eset),
    Biobase::featureNames(bulk_eset)
  )
  # IMPORTANT: This line with the intersection is a difference from the original algorithm
  genes <- base::intersect(genes, rownames(signature))
  if (base::length(genes) == 0) {
    base::stop(
      "Zero genes remaining after filtering and ",
      "intersecting bulk, single-cell, and marker genes."
    )
  }
  if (verbose) {
    n_cells <- base::ncol(sc_eset)
    base::message(
      "Generating single-cell based reference from ",
      sprintf("%i cells.\n", n_cells)
    )
  }
  sc_ref <- signature[genes, , drop = FALSE]
  sc_props <- BisqueRNA:::CalculateSCCellProportions(
    sc_eset, subject_names,
    cell_types
  )
  sc_props <- sc_props[base::colnames(sc_ref), , drop = FALSE]
  if (use_overlap) {
    if (verbose) {
      base::message("Learning bulk transformation from overlapping samples.")
    }
    Y_train <- sc_ref %*% sc_props[, samples$overlapping,
      drop = FALSE
    ]
    X_train <- Biobase::exprs(bulk_eset)[genes, samples$overlapping,
      drop = FALSE
    ]
    X_pred <- Biobase::exprs(bulk_eset)[genes, samples$remaining,
      drop = FALSE
    ]
    template <- base::numeric(base::length(samples$remaining))
    base::names(template) <- samples$remaining
    if (verbose) {
      base::message("Applying transformation to bulk samples and decomposing.")
    }
    Y_pred <- base::matrix(base::vapply(
      X = genes, FUN = BisqueRNA:::SupervisedTransformBulk,
      FUN.VALUE = template, Y_train, X_train, X_pred,
      USE.NAMES = TRUE
    ), nrow = base::length(samples$remaining))
    sample_names <- samples$remaining
  } else {
    if (verbose) {
      base::message("Inferring bulk transformation from single-cell alone.")
    }
    Y_train <- sc_ref %*% sc_props
    X_pred <- Biobase::exprs(bulk_eset)[genes, , drop = FALSE]
    sample_names <- base::colnames(Biobase::exprs(bulk_eset))
    template <- base::numeric(base::length(sample_names))
    base::names(template) <- sample_names
    if (verbose) {
      base::message("Applying transformation to bulk samples and decomposing.")
    }
    Y_pred <- base::matrix(base::vapply(
      X = genes, FUN = BisqueRNA:::SemisupervisedTransformBulk,
      FUN.VALUE = template, Y_train, X_pred, USE.NAMES = TRUE
    ),
    nrow = base::length(sample_names)
    )
  }
  indices <- base::apply(Y_pred, MARGIN = 2, FUN = function(column) {
    base::anyNA(column)
  })
  if (base::any(indices)) {
    if (verbose) {
      n_dropped <- base::sum(indices)
      base::message(base::sprintf(
        "Dropped an additional %i genes",
        n_dropped
      ), " for which a transformation could not be learned.")
    }
    if (sum(!indices) == 0) {
      base::stop("Zero genes left for decomposition.")
    }
    Y_pred <- Y_pred[, !indices, drop = FALSE]
    sc_ref <- sc_ref[!indices, , drop = FALSE]
  }
  E <- base::matrix(1, nrow = n_cell_types, ncol = n_cell_types)
  f <- base::rep(1, n_cell_types)
  G <- base::diag(n_cell_types)
  h <- base::rep(0, n_cell_types)
  results <- base::as.matrix(base::apply(Y_pred, 1, function(b) {
    sol <- limSolve::lsei(sc_ref, b, E, f, G, h)
    sol_p <- sol$X
    sol_r <- base::sqrt(sol$solutionNorm)
    return(base::append(sol_p, sol_r))
  }))
  base::rownames(results) <- base::append(
    base::colnames(sc_ref),
    "rnorm"
  )
  base::colnames(results) <- sample_names
  rnorm <- results["rnorm", , drop = TRUE]
  base::names(rnorm) <- sample_names
  Y_pred <- base::t(Y_pred)
  base::rownames(Y_pred) <- base::rownames(sc_ref)
  base::colnames(Y_pred) <- sample_names
  results <- base::list(
    bulk_props = t(results[base::colnames(sc_ref), ,
      drop = FALSE
    ]), sc_props = sc_props, rnorm = rnorm, genes_used = base::rownames(sc_ref),
    transformed_bulk = Y_pred
  )
  return(results)
}
